- [Основные понятия, требования, примеры и мотивация](#org7e43381)
  - [Аварийные ситуации](#org6d3ac3b)
  - [Обнаружение аварийной ситуации](#org42969b2)
  - [Утверждения](#orgeb6e7e1)
  - [Управление утверждениями](#orge4f64e3)
  - [Контекст утверждений](#orgf1fe910)
- [План реализации](#org5846050)

Контракты &#x2014; техника, которая сводится к "тестированию на лету". В основу контрактов для `C/C++` положена проверка логических *утверждений* (*Assert*), реализованная в виде макроса `assert`. Этот макрос аварийно завершает приложение, если заданное им утверждение не соблюдается (то есть, ложно). Для `Haskell` аналогичная возможность предоставлена в виде функции `assert`, реализованной в модуле [Control.Exception](https://hackage.haskell.org/package/base-4.16.0.0/docs/Control-Exception.html). Однако в целом программирование по контракту не сводится только к утверждениям в отдельных местах приложения. Полноценные контракты, реализованные, например, в `Eiffel`, являются регулярной системой проверок, которые задаются в описании поведения любой достаточно сложной функции. Поэтому кроме простых *проверок* (*Check*), которые являются дальнейшим развитием утверждений и могут встретиться в любом месте кода, вводятся также *требования* (*Requirement*), *гарантии* (*Ensurance*) и *инварианты* (*Invariant*). Требования можно также назвать *предусловиями* (*Precondition*), а гарантии &#x2014; *постусловиями* (*Postcondition*). Предусловия проверяются перед вызовом функции, постусловия &#x2014; в конце, а инварианты вызываются в обоих случаях. Совокупность требований, гарантий и инвариантов обычно называется *контрактом*, который определяет порядок взаимодействия функции с внешним миром.

Кроме того, с программированием по контракту тесно связаны различные способы аварийного завершения приложения. В `C` для аварийного завершения обычно используется вызов функции `exit`, в `C++` к этому механизму добавляется *генерация исключений* (*Exception*) с помощью синтаксической конструкции `throw`. При этом функция `exit` просто завершает исполнение приложения, а при генерации исключения можно дополнительно описать возникшую аварийную ситуацию. В `Haskell` так же, как и в `C++`, для аварийного завершения используется генерация исключения. Неопределенное поведение отмечается вызовом функции `undefined`, а для генерации исключения в аварийной ситуации &#x2014; функция `error`. При этом, однако, механизмы аварийного завершения в `C/C++` и стандартном `Haskell` не связаны тесно с системой контрактов, что будет продемонстрировано далее.

Таким образом, при реализации `Haskell`-модуля `Contract` ставились следующие задачи:

-   реализация полноценной системы контрактов по образцу, который предоставлен в `Eiffel`;

-   реализация удобных способов аварийного завершения приложения, как части системы контрактов.


<a id="org7e43381"></a>

# Основные понятия, требования, примеры и мотивация


<a id="org6d3ac3b"></a>

## Аварийные ситуации

Назовем *аварийной ситуацией* или просто *аварией* (*Alert*) любую генерацию исключения, которое, как правило, не обрабатывается и приводит к аварийному завершению приложения. В отличие от других типов исключительного поведения аварийная ситуация обычно вызвана логической ошибкой в коде приложения. Поэтому исключения, генерируемые в аварийной ситуации, желательно выделить в особый тип. В стандартном `Haskell` для индикации аварийной ситуации используется сразу два типа исключений &#x2014; функция `error` генерирует исключение `ErrorCall`, а функция `assert` &#x2014; исключение `AssertionFailed`. Возможно, предполагается, что такое отличие должно как-то помочь при обработке этих исключений. Но мы уже договорились, что исключение в аварийной ситуации не обрабатывается. В таком случае намного важнее *сообщение* (*Message*, `Msg`) &#x2014; строка, содержащая краткое описание аварии. И `ErrorCall` и `AssertionFailed` содержат сообщение в виде простой текстовой строки, однако тип этих исключений совершенно не влияет на текст сообщения:

```haskell
:m +Control.Exception
```

```haskell
throw $ ErrorCall "Alarm"
```

    *** Exception: Alarm

```haskell
throw $ AssertionFailed "Alarm"
```

    *** Exception: Alarm

В обоих случаях система использует один и тот же заголовок `*** Exception:`. Наверное, было бы разумно вместо абстрактного заголовка `Exception` [выводить конкретный тип исключения](contract.md).

В настоящее время тип исключения для аварийной ситуации вообще не играет никакой роли. Чтобы определить сообщение в аварийной ситуации, годится даже простая строка, достаточно только определить ее как экземпляр класса `Exception`.

<a id="orga6454a8"></a>Пример 1

```haskell
{-# LANGUAGE FlexibleInstances, TypeSynonymInstances #-}

import Control.Exception(Exception)

instance Exception String
```

```haskell
:load haskell-contract/sample/Contract.1
```

    [1 of 1] Compiling Main             ( haskell-contract/sample/Contract.1.hs, interpreted )
    Ok, one module loaded.

```haskell
throw "Alarm"
```

    *** Exception: "Alarm"

При реализации контрактов я вначале для простоты использовал исключение `ErrorCall`, которое порождается вызовом функции `error`. Однако при [тестировании аварийных ситуаций](contract.md) оказалось полезным отделить исключения, порождаемые системой контрактов, от аналогичных стандартных исключений. Поэтому был определен особый тип исключений `Alert` который и генерируется системой при возникновении аварийной ситуации.


<a id="org42969b2"></a>

## Обнаружение аварийной ситуации

Иногда аварийная ситуация означает невозможность выполнить корректные действия в сложившихся условиях. Рассмотрим, например, следующую реализацию функции `next`:

<a id="org1b09f23"></a>Пример 2

```haskell
1  next v =
2      if v < 0
3      then undefined                                         --      (not-important)
4      else if v == 1 
5           then 2
6           else if v == 2 
7                then 3
8                else undefined                               --      (not-discovered)
```

```haskell
:load haskell-contract/sample/Contract.2
```

    [1 of 1] Compiling Main             ( haskell-contract/sample/Contract.2.hs, interpreted )
    Ok, one module loaded.

По сути, эта функция должна выдавать следующее значение для своего аргумента. Однако предположим, что функция `next` определена частично, только для значений `1` и `2`. В остальных случаях поведение функции либо не важно для нас (как в строке not-important, либо мы не можем определить поведение функции для такого значения (как в строке not-discovered. Эти ситуации помечены коде стандартным вызовом `undefined`. Теперь вызов частично определенной функции `next` с недопустимым аргументом приведет к возникновению аварийной ситуации:

```haskell
next (-1)
```

    *** Exception: Prelude.undefined
    CallStack (from HasCallStack):
      error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err
      undefined, called at haskell-contract/sample/Contract.2.hs:3:10 in main:Main

```haskell
next 0
```

    *** Exception: Prelude.undefined
    CallStack (from HasCallStack):
      error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err
      undefined, called at haskell-contract/sample/Contract.2.hs:8:20 in main:Main

Мы видим, что в случае возникновения аварийной ситуации само сообщение `*** Exception: Prelude.undefined` совершенно неинформативно. Оно только сообщает, что где-то в коде была вызвана функция `undefined`, но где произошел этот вызов, и почему &#x2014; непонятно. В прежних реализациях `GHC` больше ничего не было известно. Сейчас система при аварийном завершении показывает стек вызова, что позволяет определить, хотя бы, место аварии.

Чтобы понять, насколько лучше может быть результат, воспользуемся, например, определением функции `next` по образцу:

<a id="orge0ac86f"></a>Пример 3

```haskell
1  next 1 = 2
2  next 2 = 3
```

```haskell
:load haskell-contract/sample/Contract.3
```

    [1 of 1] Compiling Main             ( haskell-contract/sample/Contract.3.hs, interpreted )
    Ok, one module loaded.

```haskell
next (-1)
```

    *** Exception: haskell-contract/sample/Contract.3.hs:(1,1)-(2,10): Non-exhaustive patterns in function next

```haskell
next 0
```

    *** Exception: haskell-contract/sample/Contract.3.hs:(1,1)-(2,10): Non-exhaustive patterns in function next

Здесь мы тоже получаем аварийную ситуацию, описанную исключением. Удивительно, но здесь, в отличие от вызова `undefined`, не показан стек вызова. Вместо этого в тексте сообщения появляется фрагмент `Contract/sample/Contract.3.hs:(1,1)-(2,10)`, описывающая место в исходном коде, где возникла ошибка. Такое описание будем называть *положением* (*Location*, *Locus*, `Loc`) аварийной ситуации. Положение может быть описано в виде структуры [Loc](https://hackage.haskell.org/package/template-haskell-2.8.0.0/docs/Language-Haskell-TH-Syntax.html#t:Loc) из модуля `Language.Haskell.TH`, при этом для наших целей удобно представлять его в виде отформатированной строки. Приведенный текстовый формат упрощает переход к месту аварии в исходном коде с помощью средств `Emacs`, поэтому постараемся использовать его в сообщении для любой аварийной ситуации.

Заметим, что даже определение функции `next` по образцу не позволяет нам различить два важных для нас случая. Попробуем исправить этот недостаток:

<a id="orgecc78ef"></a>Пример 4

```haskell
1  next v =
2    if v < 0
3    then error ("next for " ++ show v ++ " is not defined")
4    else if v == 1 
5         then 2
6         else if v == 2 
7              then 3
8              else error ("Unexpected value " ++ show v)
```

```haskell
:load haskell-contract/sample/Contract.4.hs
```

    [1 of 1] Compiling Main             ( haskell-contract/sample/Contract.4.hs, interpreted )
    Ok, one module loaded.

```haskell
next (-1)
```

    *** Exception: next for -1 is not defined
    CallStack (from HasCallStack):
      error, called at haskell-contract/sample/Contract.4.hs:3:8 in main:Main

```haskell
next 0
```

    *** Exception: Unexpected value 0
    CallStack (from HasCallStack):
      error, called at haskell-contract/sample/Contract.4.hs:8:18 in main:Main

Здесь мы попытались разделить ситуации, задав для каждой из них свой собственный вид сообщения с помощью вызова стандартной функции `error` из модуля [Err](https://downloads.haskell.org/~ghc/8.0.1-rc1/docs/html/libraries/base-4.9.0.0/src/GHC-Err.html). Раньше эта функция просто генерировала исключение `ErrorCall`:

```haskell
error :: [Char] -> a
error s = throw (ErrorCall s)
```

При такой реализации функция `error` не имеет большого смысла. В самом деле, как уже было указано раньше, мы могли бы [определить строки как разновидность исключений](#orga6454a8), после чего просто генерировать исключения напрямую. Однако новая реализация функции `error` сложнее, так как в нее добавлен стек вызова. Заметим, что `undefined` сейчас тоже реализован как специальный вызов `error`.

Очевидно, что реализация функции `error` была бы лучше, если бы к заданному сообщению автоматически добавлялось положение аварийной ситуации, как это сделано для неполного определения по образцу. Тогда сообщения об ошибке выглядели бы, например, так:

    *** Exception: Contract/sample/Contract.4.hs:(3,8)-(3,57): next for -1 is not defined

для первой ситуации и

    *** Exception: Contract/sample/Contract.4.hs:(8,18)-(8,48): Unexpected value 0

для второй.

Вместо того, чтобы изменять определение стандартной функции `error`, поведение которой для многих уже стало привычным, при реализации модуля `Contract` мы определим новую функцию `alert`, которая отличается от `error` тем, что включает в сообщение специально отформатированную информацию о положении аварийной ситуации. Позднее можно будет [добавить `alert` в стек вызова](contract.md).


<a id="orgeb6e7e1"></a>

## Утверждения

Во многих случаях желательно проверить возможность возникновения аварийной ситуации еще до того, как она реально возникнет. Как правило, это необходимо сделать при вычислении любой частично определенной функции. Возьмем в качестве примера функцию `sqrtHead`, которая вычисляет квадратный корень из первого элемента списка.

```haskell
let sqrtHead = sqrt . head
:type sqrtHead
```

    sqrtHead :: Floating c => [c] -> c

Эта функция частично определена, так как попытка применить ее к пустому списку также приводит к аварийной ситуации:

```haskell
sqrtHead []
```

    *** Exception: Prelude.head: empty list

Здесь мы опять видим старый формат вывода сообщений, без указания положения аварии и стека вызова. И если для функций `error` и `undefined` разработчики добавили, хотя бы, стек вызова, то в этом случае стандартная библиотека не включила стек вызова в описание аварии. А ведь в коде реального приложения могут быть сотни мест, где может возникнуть аналогичная проблема, и причины аварии из текста сообщения совершенно непонятны. Пример отладки в таком случае описан, например, в [этой статье](https://donsbot.wordpress.com/2007/11/14/no-more-exceptions-debugging-haskell-code-with-ghci/).

Еще одна аварийная ситуация может возникнуть, если список не пуст, но его первый элемент меньше нуля:

```haskell
sqrtHead [-5.0]
```

    NaN

Еще хуже обработка ситуации с извлечением корня из отрицательного числа: функция тихо возвращает бесполезное значение, не вызывая аварийной ситуации. При этом выполнение приложения продолжается и некорректность вычисленного значения может быть обнаружена очень далеко от места, где реально возникла ошибка.

Очевидно, что обе ситуации желательно проверить явно, например, так:

<a id="orgc3d33e1"></a>Пример 5

```haskell
1  sqrtHead [] = error "Argument list in sqrtHead is empty"
2  sqrtHead (v:_) = 
3    if v < 0
4    then error ("Head element " ++ show v ++ " of argument list in sqrtHead is negative")
5    else sqrt v
```

```haskell
:load haskell-contract/sample/Contract.5.hs
```

    [1 of 1] Compiling Main             ( haskell-contract/sample/Contract.5.hs, interpreted )
    Ok, one module loaded.

```haskell
sqrtHead []
```

    *** Exception: Argument list in sqrtHead is empty
    CallStack (from HasCallStack):
      error, called at haskell-contract/sample/Contract.5.hs:1:15 in main:Main

```haskell
sqrtHead [-5.0]
```

    *** Exception: Head element -5.0 of argument list in sqrtHead is negative
    CallStack (from HasCallStack):
      error, called at haskell-contract/sample/Contract.5.hs:4:8 in main:Main

Здесь проверки аварийных ситуаций запутывают основной код приложения. Чтобы упростить описание, воспользуемся *утверждениями* (*Assert*), которые реализованы в `Haskell` в виде стандартной функции [assert](https://hackage.haskell.org/package/base-4.16.0.0/docs/Control-Exception.html#g:14), реализованной в модуле `Control.Exception` (а также, как это ни странно, в модуле [Control.OldException](https://hackage.haskell.org/package/base-4.3.1.0/docs/Control-OldException.html#v:assert)).

<a id="orga0a1604"></a>Пример 6

```haskell
1  import Control.Exception
2  
3  sqrtHead l = 
4    assert (not $ null l)
5    assert (head l >= 0)
6    sqrt $ head l
```

```haskell
:load haskell-contract/sample/Contract.6.hs
```

    [1 of 1] Compiling Main             ( haskell-contract/sample/Contract.6.hs, interpreted )
    Ok, one module loaded.

```haskell
sqrtHead []
```

    *** Exception: Assertion failed
    CallStack (from HasCallStack):
      assert, called at haskell-contract/sample/Contract.6.hs:4:3 in main:Main

```haskell
sqrtHead [-5.0]
```

    *** Exception: Assertion failed
    CallStack (from HasCallStack):
      assert, called at haskell-contract/sample/Contract.6.hs:5:3 in main:Main

Логическое выражение, заданное в утверждении назовем *условием* (*Condition*, `Cond`). Значения аргументов, при которых условие утверждения корректно (или *удовлетворено*), назовем *областью утверждения* (*Assertion Domain*). Смысл вызова для утверждения очень прост: если условие утверждения *нарушено* (то есть, его значение ложно), то возникает аварийная ситуация, в противном случае вычисляется оставшаяся часть утверждения, которую будем называть *продолжением* (*Continuation*, `Cont`). Описанный процесс будем называть коротко *исполнением утверждения* (*Assertion Execution*). Заметим, что продолжение &#x2014; это (как правило, частично определенная) функция, имеющая свою собственную область определения (*Continuation Domain*). Область правильно заданного утверждения всегда является подмножеством области определения продолжения. Очень важно, что **область утверждения не всегда равна области определения продолжения** и может быть его строгим подмножеством. То есть, утверждение может превратить даже тотально определенную функцию продолжения в частично определенную или уменьшить область определения функции-продолжения.

В отличие от `error` функция `assert` возвращает совершенно неинформативное сообщение о причинах аварийной ситуации. Само сообщение `Assertion failed` "жестко прошито" в реализации функции `assert`. Было бы удобнее, если бы в сообщение утверждения включался, хотя бы, текст проверенного условия, например,

    *** Exception: sample\Contract-6.hs:5:3-8: "Argument list in sqrtHead is not empty" failed

для первой ситуации и

    *** Exception: sample\Contract-6.hs:7:3-8: "Head element -5.0 of argument list in sqrtHead is not negative" failed

для второй. Такое описание, по идее, должно передаваться как аргумент утверждения, например, так:

```haskell
sqrtHead l = 
  assert "Argument list in sqrtHead is not empty" (not $ null l)
  assert ("Head element " ++ (show $ head l) ++ " of argument list in sqrtHead is negative") (head l >= 0)
  sqrt $ head l
```

Попытка найти реализацию функции `assert` в исходных текстах GHC приводит к потрясающим результатам. Оказывается, в компиляторе Haskell используется несколько различных систем проверки утверждений. Например, раньше в модуле `Control.Exception.Base` использовалась наиболее очевидная реализация:

```haskell
#if !(__GLASGOW_HASKELL__ || __NHC__)
assert :: Bool -> a -> a
assert True x = x
assert False _ = throw (AssertionFailed "")
#endif
```

Занятно, что тут нет "магической" фразы `Assertion Failed`, а сам вызов этой функции выдает пустое сообщение, даже без информации о месте возникновения ошибки. Сейчас эта реализация убрана, и вместо нее приведена не менее загадочная реализация в модуле `GHC.Base`:

```haskell
-- Assertion function.  This simply ignores its boolean argument.
-- The compiler may rewrite it to @('assertError' line)@.

-- | If the first argument evaluates to 'True', then the result is the
-- second argument.  Otherwise an 'Control.Exception.AssertionFailed' exception
-- is raised, containing a 'String' with the source file and line number of the
-- call to 'assert'.
--
-- Assertions can normally be turned on or off with a compiler flag
-- (for GHC, assertions are normally on unless optimisation is turned on
-- with @-O@ or the @-fignore-asserts@
-- option is given).  When assertions are turned off, the first
-- argument to 'assert' is ignored, and the second argument is
-- returned as the result.

--      SLPJ: in 5.04 etc 'assert' is in GHC.Prim,
--      but from Template Haskell onwards it's simply
--      defined here in Base.hs
assert :: Bool -> a -> a
assert _pred r = r
```

Попытка же найти исходных текстах GHC фразу `Assertion Failed` дает, например, вот такое определение в модуле `GHC.IO.Exception`:

```haskell
assertError :: Addr# -> Bool -> a -> a
assertError str predicate v
  | predicate = v
  | otherwise = throw (AssertionFailed (untangle str "Assertion failed"))
```

В этом определении передается дополнительный параметр, который и задает положение утверждения в виде адреса строки C в памяти. Об этом говорится в разделе [7.12. Assertions](https://downloads.haskell.org/~ghc/6.12.2/docs/html/users_guide/assertions.html) руководства пользователя. Там сказано:

> Ghc will rewrite this to also include the source location where the assertion was made,
> 
> assert pred val ==> assertError "Main.hs|15" pred val
> 
> The rewrite is only performed by the compiler when it spots applications of Control.Exception.assert, so you can still define and use your own versions of assert, should you so wish. If not, import Control.Exception to make use assert in your code.

Получается, что реализация `assert` сделана с помощью хака в компиляторе, который предоставляет этой функции особую информацию о положении утверждения. Возможно, такая "грязная" реализация стала причиной того, что ее не используют регулярно, в том числе, для генерации исключений вообще и аварийных ситуаций, в частности.

Наконец, очень интересен вариант, определенный в файле [HsVersions.h](https://gitlab.haskell.org/ghc/ghc/-/blob/4ba73e00c4887b58d85131601a15d00608acaa60/compiler/HsVersions.h):

```haskell
#define ASSERT(e)      if debugIsOn && not (e) then (assertPanic __FILE__ __LINE__) else
#define ASSERT2(e,msg) if debugIsOn && not (e) then (assertPprPanic __FILE__ __LINE__ (msg)) else
#define WARN( e, msg ) (warnPprTrace (e) __FILE__ __LINE__ (msg)) $

-- Examples:   Assuming   flagSet :: String -> m Bool
--
--    do { c   <- getChar; MASSERT( isUpper c ); ... }
--    do { c   <- getChar; MASSERT2( isUpper c, text "Bad" ); ... }
--    do { str <- getStr;  ASSERTM( flagSet str ); .. }
--    do { str <- getStr;  ASSERTM2( flagSet str, text "Bad" ); .. }
--    do { str <- getStr;  WARNM2( flagSet str, text "Flag is set" ); .. }
#define MASSERT(e)      ASSERT(e) return ()
#define MASSERT2(e,msg) ASSERT2(e,msg) return ()
#define ASSERTM(e)      do { bool <- e; MASSERT(bool) }
#define ASSERTM2(e,msg) do { bool <- e; MASSERT2(bool,msg) }
#define WARNM2(e,msg)   do { bool <- e; WARN(bool, msg) return () }
```

Это очень похоже на реализацию проверок в `C/C++`, сделанную с помощью средств макропроцессора. Однако почему-то эти макроопределения используют не рекомендованную функцию `assert`, а специальную функцию `assertPanic`, реализованную в модуле [Panic](e:/cache/soft/haskell/ghc-7.0.1/compiler/utils/Panic.lhs):

```haskell
assertPanic :: String -> Int -> a
assertPanic file line = 
  Exception.throw (Exception.AssertionFailed 
           ("ASSERT failed! file " ++ file ++ ", line " ++ show line))
```

Здесь мы видим еще один вид сообщений об аварийной ситуации, причем это сообщение использут особый формат положения.

Разобраться в этом нагромождении проверочных систем мне пока что не удалось, поэтому в модуле `Contract` реализована еще одна версия утверждений с описанием.


<a id="orge4f64e3"></a>

## Управление утверждениями

При работе приложения в нормальном режиме аварийные ситуации вообще не должны возникать. Однако, если не принять дополнительных мер, проверка условий в рабочей версии все еще будет выполняться и влиять (иногда очень заметно или даже критически) на эффективность работы приложения. Просто удалить из кода приложения описание неэффективных утверждений неразумно, так как они могут понадобиться при необходимости продолжить разработку или выполнить отладку в особо запутанном случае. При "ползучей отладке" такие утверждения обычно помещаются в специальные комментарии или блоки условной компиляции, которые потом индивидуально открываются, закрываются или переключаются.

Договоримся считать утверждение *включенным* (*On*), *активным* (*Active*) или *исполняемым* (*Executable*), если оно исполняется при работе приложения. Если же утверждение описано в коде, но помещено в комментарий или отключенный блок условной компиляции, то такое утверждение будем считать *выключенным* (*Off*) или *пропущенным* (*Skip*).

Помимо возможности включать или выключать отдельные утверждения, система контрактов обычно предусматривает также удобную возможность *управления утверждениями* (*Assertion Control*) &#x2014; массового включения и выключения утверждений в различных местах приложения. Особо заметим, что управление утверждениями подразумевает именно массовое включение или выключение утверждений, то есть, перевод системы контрактов в определенный *режим работы* (*Contract Mode*).

Управление утверждений для `C/C++` использует средства макропроцессора, который отключает проверки при определении специальной макропеременной-флага `NDEBUG`. В этом случае макрос `assert` просто удаляет из кода приложения проверку условия. То есть, предоставляется два режима работы &#x2014; режим *отладки* (*Debug*), который включается по умолчанию, и режим *без отладки* (*Not Debug*), который включается указанием флага компиляции `-DNDEBUG`.

В разделе [7.12. Assertions](https://downloads.haskell.org/~ghc/6.12.2/docs/html/users_guide/assertions.html) руководства пользователя `Haskell` сказано следующее:

> GHC ignores assertions when optimisation is turned on with the -O flag. That is, expressions of the form assert pred e will be rewritten to e. You can also disable assertions using the -fignore-asserts option.

То есть, здесь также предоставляется всего два режима. В обычном режиме, включенном по умолчанию, включены все утверждения на основе стандартной функции `assert`. В режиме *оптимизации* который задается указанием флага компиляции `-O` или `-fignore-asserts` все такие утверждения выключаются.

Большой недостаток стандартной системы управления утверждениями `Haskell` в том, что она построена на хаке компилятора, который включает и выключает одну особую функцию в зависимости от флагов компиляции. Такое решение затрудняет реализацию системы контрактов, которая не зависит от конкретной реализации компилятора.

Главное достоинство стандартных систем управления утверждениями в `C/C++` и `Haskell` &#x2014; их простота. По сути, предоставляется только два режима работы &#x2014; "все утверждения включены" и "все утверждения отключены". Кроме того, за счет раздельной компиляции модулей с разными флагами можно включать или выключать утверждения на уровне отдельных модулей или их групп (пакетов). Однако такой подход иногда недостаточно гибок. Например, даже в нормальном режиме работы желательно, чтобы приложение проверяло, как минимум, корректность данных, которые оно получет из базы данных, файла или любого другого потока вввода. Назовем такие утверждения *основными* или *базовыми* (*Basic*). Как правило, отключение основных утверждений либо не влияет существенно эффективность либо является критичным для работы всего приложения. Очень часто проверку входных данных вообще реализуют как часть основного кода. Кроме того, множество вполне полезных проверок не влияет серьезно на эффективность работы и такие проверки также вполне можно считать основными.

Более гибкое (и в то же время, более сложное) управление утверждениями предоставляет система контрактов `Eiffel`, где с помощью специальных флагов компиляции можно выборочно отключить утверждения определенного типа (по умолчанию в `Eiffel` все утверждения включены). Например, можно выключить все постусловия, оставив включенными предусловия, как основную и самую важную часть контрактов. Можно отключить только инварианты, как самую неэффективную часть контракта, потому что инварианты проверяются перед входом в любую подпрограмму и после каждого выхода из нее. Наконец, можно вообще отключить все контрактные утверждения, оставив только основные проверки (как правило, входных данных). Однако, даже у такой гибкой системы есть определенные недостатки, так как в ней выбор утверждений для отключения основан на его логическом типе. На практике отключать в первую очередь нужно только те утверждения, которые в самом деле существенно влияют на эффективность работы приложения. Назовемм такие проверки *трудоемкими*, *тяжелыми* или *жесткими* (*Hard*). При отключении, например, **всех** предусловий сразу совершенно не учитывается, что некоторые из них являются трудоемкими, а некоторые &#x2014; нет. Кроме того, в `Eiffel` нет разницы между проверками, как частью контрактов, и критическими проверками, которые всегда должны выполняться.


<a id="orgf1fe910"></a>

## Контекст утверждений

В аварийной ситуации часто полезно получить конкретные значения переменных которые ее вызвали. Например, при возникновении ситуации, описанной условием `head l >= 0`, может быть получено сообщение вида

    "head l >= 0" failed

Здесь было бы очень полезно подставить в текст условия конкретные значения, которые вызвали аварию, например,

    "head [-5.0] >= 0" failed

И все же, нет смысла создавать сложную систему отображения контекста. Проще воспользоваться отладчиком GHCi, как описано в разделе [2.5.6. Debugging exceptions](https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/ghci-debugger.html#ghci-debugger-exceptions) руководства пользователя. Этот отладчик предоставляет не только непосредственный контекст, но и дает развертку всего стека.


<a id="org5846050"></a>

# План реализации

Определим специальный тип исключения `Alert`, предназначенный для описания аварийной ситуации. Такое определение позволит отделить аварийную ситуацию от общепринятых исключений ошибок (`ErrorCall`) и утверждений (`AssertionFailed`).

Для генерации аварийной ситуации мы определим свою версию функции `alert`, единственным преимуществом которой перед стандартной функцией `error` будет включение положения в текст сообщения. В перспективе в описание аварийной ситуации будет также [добавлен стек вызова](contract.md). До тех пор будет добавлен флаг компиляции, который позволит собрать пакет так, что `alert` будет просто тематическим синонимом `error`.

У функции `assert` будет пересмотрен тип (сигнатура) и семантика. Во-первых, мы добавим в параметры этой функции строку сообщения, что позволит более подробно описывать аварийную ситуацию, которая возникает в результате нарушения условия утверждения. Во-вторых, эти утверждения нельзя будет отключать, так как в языке нет стандартных средств для управления утверждениями. Такая реализация делает `assert` сложнее в использовании, однако она станет основой для реализации утверждений более высокого уровня.

Для управления утверждениями определим две функции, `skip` и `exec`, из которых основной является функция выключения утверждений `skip`. Эта функция позволяет включать или выключать только отдельные утверждения, поэтому мы определим целый класс *переключателей* (*Switch*), которые будут синонимами `skip` и `exec` в зависимости от контекста. Реализуем три стандартных переключателя `basic`, `contract` и `hard`, которые будут массово включать или выключать утверждения в соответствии с *режимом контракта*, который будет принимать четыре стандартных значения, `Off`, `Basic`, `Complete` и `Hard`.

Используя переключатели, определим три типа утверждений более высокого уровня, `check`, `requires` и `ensures`. В этой тройке утверждение `check` будет определено как базовое с помощью модификатора `basic`, который позволит выключать такие утверждения только при полном выключении системы контрактов. Утверждения `requires` и `ensures` определим как утверждения контрактов с помощью модификатора `contract`, которое позволит выключать их проверку в базовом режиме.

В специальных модулях `Contract.Off`, `Contract.Basic`, `Contract.Complete` И `Contract.Hard` определим компактные синонимы утверждений для разных режимов, при этом утверждения можно будет включать или выключать, просто импортируя соответствующий модуль. После этого соответствующий режим можно будет включать и выключать с помощью флагов компиляции. Модуль `Contract` определим как синоним модуля `Contract.Complete`, который является типичным режимом утверждений при разработке.

Для тестирования введем понятие *ожидаемой* аварийной ситуации и включим проверку такого ожидания в рамках системы тестирования `QuickCheck`.

Как развитие системы контрактов рассмотрим реализацию функций `variant` и `invariant`. В `Eiffel` варианты используются для проверки завершимости циклов. По сути это не логические утверждения, а всего лишь ограниченные дискретные значения (чаще всего неотрицательные целые числа). В `Haskell` нет циклов, поэтому реализация вариантов имеет свои особенности. Что же касается инвариантов, они (неожиданно!) имеют неоднозначную семантику. А именно, логично считать инварианты противоположностью вариантам, то есть, это некое значение, которое сохраняется между итерациями цикла или вызовами. Однако, даже в `Eiffel` под инвариантами понимаются только логические условия, которые являются комбинациями пред- и постусловий. В этом смысле правильнее говорить об универсальном свойстве `valid`, которое проверяется перед и после вызова функции.

Появление монад требует расширение утверждений-контрактов, однако делает их ближе к их императивным аналогам. Поэтому отдельно реализуются монадические версии утверждений `checkM`, `requiresM` и `ensuresM`.

В перспективе необходимо исследовать возможность утверждений о внутренних данных монад.
